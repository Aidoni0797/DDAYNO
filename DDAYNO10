DDAYNO10
Мета-класс и методы моделей Django
Что такое мета-класс модели?

Мы уженаучились описывать поля модели. Теперь пришло время разобраться с мета-классом. В Django мета-класс (он же class Meta) позволяет задать дополнительные настройки  для модели. Это 
не про сами данные, а скорее - про то, как с ними работать.
Мета-класс не обяззателен, но часто помогает задать повдеение модели - например, как сортировать записи, как называть таблиу в базе, и что показывать в админке.

Как выглядит мета-класс?

from django.db import models

class Person(models.Model):
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)

  class Meta:
    #настройки модели
    ...

Часто используемые мета-опции
- verbose_name - читаемое имя модели (в единственном числе) для админки
- verbose_name_plural - имя во множественном числе.

class Meta:
  verbose_name = 'Человек'
  verbose_name_plural = 'Люди'

Если не указать эти параметры, Django сам сгенерирует названия: например, person-> person и people
ordering - сортировка по умолчанию

Позволяет задать порядок, в котором объекты модели будут выводиться из базы данных. Указывается список полей, по которым сортировать. Знак минус означает убывание.

class Meta:
  get_latest_by = 'created_at'

db_table - задать имя таблицы в базе

По умолчанию имя таблицы создаётся автоматически (например, appname_modelname). Но можно явно указать своё:

class Meta:
  db_table = 'custom_table_name'

Уникальная комбинация полей в django 5+
Если нужно, чтобы определённая пара (или группа) полей была уникальной (например, нельзя было добавить двух людей с одинаковым сочетанием имени и фамилии), используйте UniqueConstraint
через параметр constraints внутри Meta:

from djnago.db import models

class Person(models.Model):
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)

  class Meta:
    constraints = [
      models.UniqueConstraint(
        fields=['first_name', 'last_name'],
        name - 'unique_full_name'
      )
    ]

Теперь при попытке добавить двух людей с одинаковым first_name и last_name, Django выбросит ошибку валидации.
Важно: раньше для этого использовался unique_together, но начиная с Dkango 4.2 он устарел и больше не рекомендуетсся. Используйте UniqueConstraint

indexes - добавление индексов

Чтобы ускорить выборку по определенным полям, можно создать индекс.

class Meta:
  permissions = [
    ('can_moderate', 'Может модерировать записи'),
  ]

abstract = true - абстрактные модели

Абстрактная модель не создаёт свою таблицу в базе, но может быть унаследована другими моделями.

class Meta:
  abstract = True

Полезно, есть есть повторяющиеся поля (например, created_at, updated_at) - можно вынести их в базовую абстрактную модель

proxy=True - прокси-модели

Прокси-модель не создаёт новую таблицу, а использует таблицу родителя. Зачем она нужна? Чтобы изменить поведение модели: например, сортировку или добавить метода,
не затрагивая оригинал.

class PersonProxy(Person):
  class Meta:
    proxy = True
    ordering = ['last_name']

app_label - указать, к какому приложению относится модель

Это бывает нужно, если модель физически находится в одном приложении, но логически относится к другому.

class Meta:
  app_label = 'users'

Заключение по Meta

Мета-опции дают много гибкости, не затрагивая поля или структуру таблицы. Их можно не использовать вообще, но если вы хотите иметь полный контроль над поведением модели - они вам точно 
пригодятся.

Методы моделей Django
В Django вы можете добавлять методы прямо в класс модели. Это не только удобно, но и помогает держать бизнес-логику рядом с данными, к которым она относится.

Зачем нужны методы у моделей?

Методы модели позволяют:
- Валидировать данные, входящие за рамки обычных validators
- Форматировать вывод, например в шаблонах
- Выичслить URL-адрес объекта
- Добавлять действия (например, отправку email, работу с API)
- Работать с файлами
- Настраивать поведение при сохранении или удалении объекта

__str__() - строковое представление объекта

Это один из самых часто используемых методов. он нужен, чтобы Django понимал, как отображать объект модели в виде строки - например, в админке или шаблонах.

class Person(models.Model):
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)

  def __str__(self):
    return f"{self.fisrt_name} {self.last_name}"

get_absolute_url() - получить ссылку на объект

Этот метод возвращает URL для конкретного объекта. Он не обязателен, но очень полезен, если вы используете DetailView или создаёте ссылки в шаблонах.

Простой пример:

class Person(models.Model):
  ...
  def get_absolute_url(self):
    return f"/person/{self.pk}/"

Более надёжный способ - через reverse():

from django.urls import reverse

class Person(models.Model):
  ...
  def get_absolute_url(self):
    return reverse('person-detail', kwargs={'pk':self.pk})

Если у вас есть маршрут вроде:
path('person/<int:pk>/', views.person, name='person-detail')

... то метод get_absolute_url() будет строить правильные ссылки на основе pk объекта.

Продолжим - с места, на котором остановились: дргуие полезные методы модели Django

Другие полезные методы моделей
clean() - кастомная валидация объекта

Метод clean() позволяет реализовать собственные правила валидации на уровне модели. Это особенно полезно, когда нужно проверить взаимосвязь 
нескольких полей или применить логику, которую нельзя описать в параметрах самих полей.

class Event(models.Model):
  title = models.CharField(max_length=100)
  start_date = models.DateField()
  end_date = models.DateField()

  def clean(self):
    #Проверка: дата окончания не раньше даты начала
    if self.end_date<self.start_date:
      raise ValidationError('Дата окончания не может быть раньше даты начала.')

clean() - вызывается вручную, но автоматически запускается внутри full_clean() и в админке при сохранении объектов.

full_clean() - проверка всех полей модели

Метод full_clean():
- запускается валидацию всех полей модели
- вызывает метод clean() (если он есть)
- поднимает исключение ValidationError, если что-то не так
Обычно используется, если вы хотите явно вызвать валидацию перед сохранением объекта:
person = Person(first_name='', last_name='Smith')
person.full_clean() #выбросит ValidationError, если first_name пустой

save() - переопределение сохранения

Метод save() вызывается при сохранении объекта в базу данных. Часто его переопределяют, чтобы изменить повердение перед/после сохранения:

class Article(models.Model):
  title = models.charField(max_length=200)
  slug = models.SlugField(unique=True, blank = True)

  def save(self, *args, **kwrags):
    if not self.slug:
      self.slug = slugify(self.title)
    super().save(*args, **kwargs)

Важно: не забывайте вызывать super().save() - иначе объект не сохранится.

delete() - переопределение удаления

Аналогично save(), метод  delete() можно переопределить, если вы хотите, чтобы при удалении объекта выполнялись дополнительные действия - 
например, логирование, уадление файлов и т.д.

class File(models.Model):
  name = models.CharField(max_length=100)
  file=models.FileField(upload_to='uploads/')

