DDAYNO10
Мета-класс и методы моделей Django
Что такое мета-класс модели?

Мы уженаучились описывать поля модели. Теперь пришло время разобраться с мета-классом. В Django мета-класс (он же class Meta) позволяет задать дополнительные настройки  для модели. Это 
не про сами данные, а скорее - про то, как с ними работать.
Мета-класс не обяззателен, но часто помогает задать повдеение модели - например, как сортировать записи, как называть таблиу в базе, и что показывать в админке.

Как выглядит мета-класс?

from django.db import models

class Person(models.Model):
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)

  class Meta:
    #настройки модели
    ...

Часто используемые мета-опции
- verbose_name - читаемое имя модели (в единственном числе) для админки
- verbose_name_plural - имя во множественном числе.

class Meta:
  verbose_name = 'Человек'
  verbose_name_plural = 'Люди'

Если не указать эти параметры, Django сам сгенерирует названия: например, person-> person и people
ordering - сортировка по умолчанию

Позволяет задать порядок, в котором объекты модели будут выводиться из базы данных. Указывается список полей, по которым сортировать. Знак минус означает убывание.

class Meta:
  get_latest_by = 'created_at'

db_table - задать имя таблицы в базе

По умолчанию имя таблицы создаётся автоматически (например, appname_modelname). Но можно явно указать своё:

class Meta:
  db_table = 'custom_table_name'

Уникальная комбинация полей в django 5+
Если нужно, чтобы определённая пара (или группа) полей была уникальной (например, нельзя было добавить двух людей с одинаковым сочетанием имени и фамилии), используйте UniqueConstraint
через параметр constraints внутри Meta:

from djnago.db import models

class Person(models.Model):
  first_name = models.CharField(max_length=30)
  last_name = models.CharField(max_length=30)

  class Meta:
    constraints = [
      models.UniqueConstraint(
        fields=['first_name', 'last_name'],
        name - 'unique_full_name'
      )
    ]

Теперь при попытке добавить двух людей с одинаковым first_name и last_name, Django выбросит ошибку валидации.
Важно: раньше для этого использовался unique_together, но начиная с Dkango 4.2 он устарел и больше не рекомендуетсся. Используйте UniqueConstraint

indexes - добавление индексов

Чтобы ускорить выборку по определенным полям, можно создать индекс.

class Meta:
  permissions = [
    ('can_moderate', 'Может модерировать записи'),
  ]

abstract = true - абстрактные модели

Абстрактная модель не создаёт свою таблицу в базе, но может быть унаследована другими моделями.

class Meta:
  abstract = True

Полезно, есть есть повторяющиеся поля (например, created_at, updated_at) - можно вынести их в базовую абстрактную модель

proxy=True - прокси-модели

Прокси-модель не создаёт новую таблицу, а использует таблицу родителя. Зачем она нужна? Чтобы изменить поведение модели: например, сортировку или добавить метода,
не затрагивая оригинал.

class PersonProxy(Person):
  class Meta:
    proxy = True
    ordering = ['last_name']

app_label - указать, к какому приложению относится модель

Это бывает нужно, если модель физически находится в одном приложении, но логически относится к другому.

class Meta:
  app_label = 'users'

Заключение по Meta

Мета-опции дают много гибкости, не затрагивая поля или структуру таблицы
